//# Program: "DockoMatic"
//# Project: "DNA Safeguard"
//# Filename: "openerTopComponent.java"
//#
//# Dr. Tim Andersen
//# Department of Computer Science
//# College of Engineering
//# Boise State University
//#
//# Original Author(s): "Casey Bullock"
//#                     "Nic Cornia"
//#
//# Last Modified
//#   Date: "November 14, 2012"
//#
//#
//#  This file is part of DockoMatic.
//#
//#  DockoMatic is free software: you can redistribute it and/or modify
//#  it under the terms of the GNU Lesser General Public License as published by
//#  the Free Software Foundation, either version 3 of the License, or
//#  (at your option) any later version.
//#
//#  DockoMatic is distributed in the hope that it will be useful,
//#  but WITHOUT ANY WARRANTY; without even the implied warranty of
//#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//#  GNU Lesser General Public License for more details.
//#
//#  You should have received a copy of the GNU Lesser General Public License
//#  along with DockoMatic.  If not, see <http://www.gnu.org/licenses/>.
//#

/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package mainWindow;

import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;
import java.util.logging.Logger;
import javax.swing.JTable;
import javax.swing.SwingWorker;
import javax.swing.Timer;
import javax.swing.table.DefaultTableModel;
import mutantScreening.GeneticAlgorithm;
import mutantScreening.ParameterSet;
import mutantScreening.mutantScreeningWizardAction;
import org.netbeans.api.settings.ConvertAsProperties;
import org.openide.util.NbBundle;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;
import utilities.ExtensionFileFilter;
import utilities.Job;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(dtd = "-//mainWindow//opener//EN",
autostore = false)
public final class openerTopComponent extends TopComponent {
    
    public static final int PADDING = 6;
    private HashMap jobList = new HashMap();
    private ArrayList<String> ligList = new ArrayList<String>();
    private ArrayList<String> recList = new ArrayList<String>();
    private ArrayList<String> boxList = new ArrayList<String>();
    private ArrayList<String> appList = new ArrayList<String>();
    private Timer jobTimer;
    private boolean tabFlag = false;
    private boolean allJobsDone = false;
    private DefaultTableModel model;
    private JTable table;
    private int currJobNumber = 0;
    private int totalJobs = 0;
    private boolean ligFromModeller = false;
    private boolean mutationScreening = false;  //tlong
    private boolean recFromModeller = false;
    private boolean useVina = false;
    private boolean ligLstBool = false;
    private boolean recListBool = false;
    private boolean boxListBool = false;
    private boolean appListBool = false;
    private File outDir;
    private File ligFile;
    private File recFile;
    private File boxFile;
    private File appFile;
    private int exceptionNum = 0;
    private String lastOutDir = System.getProperty("user.home");
    private String lastLigDir = System.getProperty("user.home");
    private String lastBoxDir = System.getProperty("user.home");
    private String lastRecDir = System.getProperty("user.home");
    private String lastAppendDir = System.getProperty("user.home");
    private String resChkGpf;
    private String errorLog = "";
    private ParameterSet mutantScreenParameters; //tlong
    private static modWizWizardAction act;// = new modWizWizardAction();
    private static openerTopComponent instance;
    
    /**
     * path to the icon used by the component and its open action
     */
    private static final String PREFERRED_ID = "openerTopComponent";

    public openerTopComponent() {
        initComponents();
        setName(NbBundle.getMessage(openerTopComponent.class, "CTL_openerTopComponent"));
        setToolTipText(NbBundle.getMessage(openerTopComponent.class, "HINT_openerTopComponent"));
        act = new modWizWizardAction();
    }

    protected static void setAppVis(boolean bool) {
        appCheckBox.setEnabled(bool);
        appendField.setEnabled(bool);
        appendButton.setEnabled(bool);

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jPanel1 = new javax.swing.JPanel();
        jPanel8 = new javax.swing.JPanel();
        newTabChBox = new javax.swing.JCheckBox();
        newJobButton = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JSeparator();
        jLabel2 = new javax.swing.JLabel();
        swmJobNum = new javax.swing.JTextField();
        swmCmdOpts = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        MutationsCheckBox = new javax.swing.JCheckBox();
        jPanel9 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        dockCycles = new javax.swing.JTextField();
        vinaCheckBox = new javax.swing.JCheckBox();
        jSeparator2 = new javax.swing.JSeparator();
        outDirButton = new javax.swing.JButton();
        outDirField = new javax.swing.JTextField();
        jSeparator3 = new javax.swing.JSeparator();
        ligandCheckBox = new javax.swing.JCheckBox();
        ligModCheckBox = new javax.swing.JCheckBox();
        LigandButton = new javax.swing.JButton();
        ligandField = new javax.swing.JTextField();
        jSeparator4 = new javax.swing.JSeparator();
        appCheckBox = new javax.swing.JCheckBox();
        appendButton = new javax.swing.JButton();
        appendField = new javax.swing.JTextField();
        jSeparator5 = new javax.swing.JSeparator();
        receptorCheckBox = new javax.swing.JCheckBox();
        recModCheckBox = new javax.swing.JCheckBox();
        receptorButton = new javax.swing.JButton();
        receptorField = new javax.swing.JTextField();
        jSeparator6 = new javax.swing.JSeparator();
        boxCoordCheckBox = new javax.swing.JCheckBox();
        boxCoordButton = new javax.swing.JButton();
        boxCoordField = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        jPanel10 = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();

        jPanel1.setPreferredSize(new java.awt.Dimension(825, 595));

        jPanel8.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jPanel8.setPreferredSize(new java.awt.Dimension(393, 133));

        org.openide.awt.Mnemonics.setLocalizedText(newTabChBox, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.newTabChBox.text")); // NOI18N
        newTabChBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                newTabChBoxActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(newJobButton, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.newJobButton.text")); // NOI18N
        newJobButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                newJobButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.jLabel2.text")); // NOI18N

        swmJobNum.setText(org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.swmJobNum.text")); // NOI18N
        swmJobNum.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                swmJobNumKeyReleased(evt);
            }
        });

        swmCmdOpts.setText(org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.swmCmdOpts.text")); // NOI18N
        swmCmdOpts.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                swmCmdOptsActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(jLabel5, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.jLabel5.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(MutationsCheckBox, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.MutationsCheckBox.text")); // NOI18N
        MutationsCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MutationsCheckBoxActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel8Layout = new javax.swing.GroupLayout(jPanel8);
        jPanel8.setLayout(jPanel8Layout);
        jPanel8Layout.setHorizontalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel8Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel8Layout.createSequentialGroup()
                        .addComponent(newJobButton, javax.swing.GroupLayout.DEFAULT_SIZE, 460, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(MutationsCheckBox)
                        .addGap(18, 18, 18)
                        .addComponent(newTabChBox))
                    .addComponent(jSeparator1)
                    .addGroup(jPanel8Layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addGroup(jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(swmJobNum, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 145, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel5)
                            .addComponent(swmCmdOpts, javax.swing.GroupLayout.PREFERRED_SIZE, 596, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addContainerGap())
        );
        jPanel8Layout.setVerticalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel8Layout.createSequentialGroup()
                .addContainerGap(16, Short.MAX_VALUE)
                .addGroup(jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jLabel5))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(swmJobNum, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(swmCmdOpts, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(newJobButton)
                    .addComponent(newTabChBox, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(MutationsCheckBox))
                .addContainerGap())
        );

        jPanel9.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jPanel9.setPreferredSize(new java.awt.Dimension(393, 133));

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.jLabel1.text")); // NOI18N

        dockCycles.setText(org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.dockCycles.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(vinaCheckBox, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.vinaCheckBox.text")); // NOI18N
        vinaCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                vinaCheckBoxActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(outDirButton, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.outDirButton.text")); // NOI18N
        outDirButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                outDirButtonActionPerformed(evt);
            }
        });

        outDirField.setText(org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.outDirField.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(ligandCheckBox, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.ligandCheckBox.text")); // NOI18N
        ligandCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ligandCheckBoxActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(ligModCheckBox, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.ligModCheckBox.text")); // NOI18N
        ligModCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ligModCheckBoxActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(LigandButton, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.LigandButton.text")); // NOI18N
        LigandButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                LigandButtonActionPerformed(evt);
            }
        });

        ligandField.setText(org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.ligandField.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(appCheckBox, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.appCheckBox.text")); // NOI18N
        appCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                appCheckBoxActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(appendButton, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.appendButton.text")); // NOI18N
        appendButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                appendButtonActionPerformed(evt);
            }
        });

        appendField.setText(org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.appendField.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(receptorCheckBox, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.receptorCheckBox.text")); // NOI18N
        receptorCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                receptorCheckBoxActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(recModCheckBox, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.recModCheckBox.text")); // NOI18N
        recModCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                recModCheckBoxActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(receptorButton, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.receptorButton.text")); // NOI18N
        receptorButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                receptorButtonActionPerformed(evt);
            }
        });

        receptorField.setText(org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.receptorField.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(boxCoordCheckBox, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.boxCoordCheckBox.text")); // NOI18N
        boxCoordCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                boxCoordCheckBoxActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(boxCoordButton, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.boxCoordButton.text")); // NOI18N
        boxCoordButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                boxCoordButtonActionPerformed(evt);
            }
        });

        boxCoordField.setText(org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.boxCoordField.text")); // NOI18N

        javax.swing.GroupLayout jPanel9Layout = new javax.swing.GroupLayout(jPanel9);
        jPanel9.setLayout(jPanel9Layout);
        jPanel9Layout.setHorizontalGroup(
            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel9Layout.createSequentialGroup()
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel9Layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(ligandCheckBox)
                            .addComponent(receptorCheckBox))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel9Layout.createSequentialGroup()
                                .addGap(81, 81, 81)
                                .addComponent(ligModCheckBox))
                            .addComponent(recModCheckBox)))
                    .addGroup(jPanel9Layout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addComponent(boxCoordCheckBox))
                    .addGroup(jPanel9Layout.createSequentialGroup()
                        .addGap(12, 12, 12)
                        .addComponent(appCheckBox)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(LigandButton, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(appendButton, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(receptorButton, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(boxCoordButton, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(ligandField)
                    .addComponent(receptorField)
                    .addComponent(boxCoordField)
                    .addComponent(appendField))
                .addContainerGap())
            .addGroup(jPanel9Layout.createSequentialGroup()
                .addGap(12, 12, 12)
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel9Layout.createSequentialGroup()
                        .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(dockCycles)
                            .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(vinaCheckBox)
                        .addGap(435, 435, 435))
                    .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(jPanel9Layout.createSequentialGroup()
                            .addComponent(jSeparator2)
                            .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGroup(jPanel9Layout.createSequentialGroup()
                            .addComponent(outDirButton, javax.swing.GroupLayout.PREFERRED_SIZE, 184, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(outDirField, javax.swing.GroupLayout.DEFAULT_SIZE, 295, Short.MAX_VALUE)
                            .addContainerGap(297, Short.MAX_VALUE))
                        .addGroup(jPanel9Layout.createSequentialGroup()
                            .addComponent(jSeparator3)
                            .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGroup(jPanel9Layout.createSequentialGroup()
                            .addComponent(jSeparator4)
                            .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGroup(jPanel9Layout.createSequentialGroup()
                            .addComponent(jSeparator5)
                            .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGroup(jPanel9Layout.createSequentialGroup()
                            .addComponent(jSeparator6)
                            .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))))
        );
        jPanel9Layout.setVerticalGroup(
            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel9Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGap(9, 9, 9)
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(dockCycles, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(vinaCheckBox))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(outDirButton)
                    .addComponent(outDirField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator3, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ligandCheckBox)
                    .addComponent(ligModCheckBox)
                    .addComponent(LigandButton)
                    .addComponent(ligandField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator4, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(appCheckBox)
                    .addComponent(appendButton)
                    .addComponent(appendField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator5, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(receptorCheckBox)
                    .addComponent(recModCheckBox)
                    .addComponent(receptorButton)
                    .addComponent(receptorField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSeparator6, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(boxCoordCheckBox)
                    .addComponent(boxCoordButton)
                    .addComponent(boxCoordField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(17, Short.MAX_VALUE))
        );

        jLabel3.setIcon(new javax.swing.ImageIcon(getClass().getResource("/mainWindow/DNA.png"))); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.jLabel3.text")); // NOI18N

        jPanel10.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jLabel4.setIcon(new javax.swing.ImageIcon(getClass().getResource("/mainWindow/BSUlogo.gif"))); // NOI18N
        org.openide.awt.Mnemonics.setLocalizedText(jLabel4, org.openide.util.NbBundle.getMessage(openerTopComponent.class, "openerTopComponent.jLabel4.text")); // NOI18N

        javax.swing.GroupLayout jPanel10Layout = new javax.swing.GroupLayout(jPanel10);
        jPanel10.setLayout(jPanel10Layout);
        jPanel10Layout.setHorizontalGroup(
            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel10Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel4)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel10Layout.setVerticalGroup(
            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel10Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel4)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addComponent(jPanel8, javax.swing.GroupLayout.PREFERRED_SIZE, 800, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jPanel9, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 800, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jPanel10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)))
                .addContainerGap(13, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel9, javax.swing.GroupLayout.PREFERRED_SIZE, 338, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel8, javax.swing.GroupLayout.PREFERRED_SIZE, 134, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel10, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jScrollPane1.setViewportView(jPanel1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING)
        );
    }// </editor-fold>//GEN-END:initComponents

    // Prompt window to select a directory from the filesystem.
    private String getDirChoose(String lastDir, String title) {
        String dir = null;
        javax.swing.JFileChooser fc = new javax.swing.JFileChooser(lastDir);
        fc.setDialogTitle(title);
        fc.setFileSelectionMode(javax.swing.JFileChooser.DIRECTORIES_ONLY);
        int retval = fc.showOpenDialog(this);
        if (retval == fc.APPROVE_OPTION) {
            dir = fc.getSelectedFile().getPath();
        }

        return dir;

    }

    // Prompt window to select a file from the filesystem.
    private String getFileChoose(String lastDir, String title, String type) {
        String file = null;
        javax.swing.JFileChooser fc = new javax.swing.JFileChooser(lastDir);
        fc.setDialogTitle(title);
        fc.setAcceptAllFileFilterUsed(false);

        if (type.equals("lpdb") && !ligLstBool) {
            fc.addChoosableFileFilter(new ExtensionFileFilter(ExtensionFileFilter.pdb));
        }
        if (type.equals("apdb") && !appListBool) {
            fc.addChoosableFileFilter(new ExtensionFileFilter(ExtensionFileFilter.pdb));
        }
        if (type.equals("rpdb") && !recListBool) {
            fc.addChoosableFileFilter(new ExtensionFileFilter(ExtensionFileFilter.pdb));
        }
        if (type.equals("gpf") && !boxListBool) {
            fc.addChoosableFileFilter(new ExtensionFileFilter(ExtensionFileFilter.gpf));
        }
        if (type.equals("txt") && !boxListBool) {
            fc.addChoosableFileFilter(new ExtensionFileFilter(ExtensionFileFilter.txt));
        }

        fc.setAcceptAllFileFilterUsed(true);
        fc.setFileSelectionMode(javax.swing.JFileChooser.FILES_ONLY);
        int retval = fc.showOpenDialog(this);
        if (retval == fc.APPROVE_OPTION) {
            file = fc.getSelectedFile().getPath();
        }

        return file;
    }

    private void outDirButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_outDirButtonActionPerformed
        String dir = getDirChoose(lastOutDir, "Select Output Directory");
        if (dir != null) {
            lastOutDir = dir;
            outDirField.setText(lastOutDir);
            String old_cmds = swmCmdOpts.getText();
            int divideAt = old_cmds.indexOf("-f ") + "-f ".length();
            String new_cmds = old_cmds.substring(0,divideAt);
            new_cmds += dir + File.separator + old_cmds.substring(divideAt);
            swmCmdOpts.setText(new_cmds);
        }
    }//GEN-LAST:event_outDirButtonActionPerformed

    private void LigandButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_LigandButtonActionPerformed
        //Create Ligand with Modeller
        if (ligFromModeller) {
            String ret = act.doWizard("ligand");
            ligandField.setText(ret);
            return;
        }
        String file = getFileChoose(lastLigDir, "Select Ligand File", "lpdb");
        if (file != null) {
            lastLigDir = file.substring(0, file.lastIndexOf(File.separator));
            ligandField.setText(file);
        }
    }//GEN-LAST:event_LigandButtonActionPerformed

    private void receptorButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_receptorButtonActionPerformed
        //Create Receptor with Modeller
        if (recFromModeller) {
            String ret = act.doWizard("receptor");
            receptorField.setText(ret);
            return;
        }
        String file = getFileChoose(lastRecDir, "Select Receptor File", "rpdb");
        if (file != null) {
            lastRecDir = file.substring(0, file.lastIndexOf(File.separator));
            receptorField.setText(file);
        }
    }//GEN-LAST:event_receptorButtonActionPerformed
    
        //tlong added
//    private void MutationsCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {                                                  
//        if(MutationsCheckBox.isSelected())
//        {
//            if(ligandField.getText().trim().equals("") || receptorField.getText().trim().equals("") || boxCoordField.getText().trim().equals(""))
//            {
//                messageWindowTopComponent.messageArea.append("Please specify a ligand, a receptor, and box coordinates in the appropriate fields above.\n");
//                MutationsCheckBox.setSelected(false);
//            }
//            else
//            {
//                mutationWindow = new mutationOptionsTopComponent();
//                if(mutationWindow.setFullSequence(ligandField.getText().trim()))
//                {
//                    mutationsTest = true; //tlong   Open new tab
//                    mutationWindow.open();
//                    mutationWindow.requestActive();
//                }
//                else
//                {
//                    messageWindowTopComponent.messageArea.append("Unable to determine the amino acid sequence from the ligand's pdb file.\n" +
//                                                                "Please make sure that it contains the necessary SEQRES lines before trying again.\n");
//                    MutationsCheckBox.setSelected(false);
//                }
//            }
//        }
//        else
//            mutationsTest = false;
//    } 

    private void boxCoordButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_boxCoordButtonActionPerformed
        String file;
        if (useVina) {
            file = getFileChoose(lastBoxDir, "Select AutoDock Vina Config File", "txt");
        } else {
            file = getFileChoose(lastBoxDir, "Select AutoDock Box Coordinate File", "gpf");
        }

        if (file != null) {
            lastBoxDir = file.substring(0, file.lastIndexOf(File.separator));
            boxCoordField.setText(file);
        }
    }//GEN-LAST:event_boxCoordButtonActionPerformed

    private void appendButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_appendButtonActionPerformed
        String file = getFileChoose(lastAppendDir, "Select Secondary Ligand File", "apdb");
        if (file != null) {
            lastAppendDir = file.substring(0, file.lastIndexOf(File.separator));
            appendField.setText(file);
        }
    }//GEN-LAST:event_appendButtonActionPerformed

    private void ligandCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ligandCheckBoxActionPerformed
        if (ligandCheckBox.isSelected()) {
            ligLstBool = true;
        } else {
            ligLstBool = false;
        }
    }//GEN-LAST:event_ligandCheckBoxActionPerformed

    private void receptorCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_receptorCheckBoxActionPerformed
        if (receptorCheckBox.isSelected()) {
            recListBool = true;
        } else {
            recListBool = false;
        }
    }//GEN-LAST:event_receptorCheckBoxActionPerformed

    private void boxCoordCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_boxCoordCheckBoxActionPerformed
        if (boxCoordCheckBox.isSelected()) {
            boxListBool = true;
        } else {
            boxListBool = false;
        }
    }//GEN-LAST:event_boxCoordCheckBoxActionPerformed

    private void appCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_appCheckBoxActionPerformed
        if (appCheckBox.isSelected()) {
            appListBool = true;
        } else {
            appListBool = false;
        }
    }//GEN-LAST:event_appCheckBoxActionPerformed

    private void newJobButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newJobButtonActionPerformed
        SwingWorker jobMakeWorker = new SwingWorker<String, Void>() {

            @Override
            public String doInBackground() {
                if(mutationScreening && !mutantScreenParameters.isExhaustiveScreen()){  //run GA if true
                    runGeneticAlgorithm();
                }else{
                    try {
                        if (outDirField.getText().trim().length() < 1) {
                            messageWindowTopComponent.appendText("No Output Directory Supplied\nUsing Current Directory '.'\n");
                            outDirField.setText(".");
                        }
                        String tmp = ligandField.getText();
                        if (tmp.length() > 0) {
                            outDir = new File(outDirField.getText().trim());
                            alignJobNums();

                            makeJobs();
                            messageWindowTopComponent.appendText("Highlight and Right-Click Jobs in Output Grid for options.\n");
                        } else {
                            messageWindowTopComponent.appendText("Ligand needs to be supplied!\n");
                        }
                    } catch (IOException e) {
                        messageWindowTopComponent.appendText("Incorrect IVS setup: Receptor List and\n Box Coordinate List need to be the same legth\n");
                    }
                }
                return "Done";
            }
        };

        jobMakeWorker.execute();
    }//GEN-LAST:event_newJobButtonActionPerformed

    protected static void startSelected(java.awt.event.MouseEvent e, java.awt.event.MouseEvent evtOrig) {
        instance.StartSelectedJobActionPerformed(e);

    }

    protected static void removeSelected(java.awt.event.MouseEvent e, java.awt.event.MouseEvent evtOrig) {
        instance.removeSelectedJobActionPerformed(e);
    }

    protected static void pymolView(java.awt.event.MouseEvent e, java.awt.event.MouseEvent evtOrig) {
        instance.pymolActionPerformed(evtOrig);
    }

    protected static void checkRes(java.awt.event.MouseEvent e, java.awt.event.MouseEvent evtOrig) {
        instance.getResCheckInfo();
        instance.avgActionPerformed(evtOrig);
    }

    private void getResCheckInfo() {
        String file = getFileChoose(lastBoxDir, "Select GPF File for Result Checking", "gpf");
        if (file != null) {
            lastBoxDir = file.substring(0, file.lastIndexOf(File.separator));
            resChkGpf = file;
        }

    }
    
    //tlong
    private void runGeneticAlgorithm(){
        
        String[] origSeqWithIndex = new String[mutantScreenParameters.getOrigSiteAcids().length()];
        
        for(int i =0; i < origSeqWithIndex.length; i++){
            origSeqWithIndex[i] = mutantScreenParameters.getOrigSiteAcids().charAt(i) + "" + mutantScreenParameters.getSubstitution_sites()[i];
	}
        
        //TODO validate these
        int cycles = Integer.parseInt(dockCycles.getText());  //default to 100 if empty
        File outputDirectory = new File(outDirField.getText().trim());   //use current directory if empty
        String lig_path = ligandField.getText();
        String rec_path = receptorField.getText();
        String box_path = boxCoordField.getText();
        String swarmCmd = swmCmdOpts.getText();
        
        if(lig_path.isEmpty() || rec_path.isEmpty() || box_path.isEmpty()){
            messageWindowTopComponent.appendText("A ligand, receptor, and box coordinates must be entered before proceeding.\n");
        }else{
            Random rand = new Random();  //TODO allow user to enter a seed (4th wizard screen)
            int verbosity = 1;           //TODO set this to a desirable value
            GeneticAlgorithm ga = new GeneticAlgorithm(mutantScreenParameters.getElitism(), mutantScreenParameters.getMutation_rate(),mutantScreenParameters.getCluster_size(),
                mutantScreenParameters.getSubstitution_sites(),mutantScreenParameters.getConstraint_set(),rand,verbosity);
            
            ga.createDockEngine(cycles, mutantScreenParameters.getSmooth_num(), outputDirectory, lig_path, rec_path, box_path, swarmCmd, origSeqWithIndex);
        
            ga.restoreState();
            ga.initPopulation(null);
            int numJobs = ga.cycle(null, mutantScreenParameters.getNum_crossover_cycles(), mutantScreenParameters.getTopX(), mutantScreenParameters.getNum_crossover_points());
            numJobs += ga.cycle(null, mutantScreenParameters.getNum_mutation_cycles(), mutantScreenParameters.getTopX(), 0);  //run with mutations only
            
            messageWindowTopComponent.appendText("The genetic algorithm has completed after docking " + numJobs + " mutants across " + ga.getGenerations() + " generations\n");
            
            //TODO summarize and show results
        }
    }

    // Checks the status of jobs and sets them to Done if they are.
    private void checkStatusButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkStatusButtonActionPerformed
        int max = outputGridTopComponent.outGridTPane.getTabCount();
        int jobNum;
        int row = 0;
        allJobsDone = true;  //temporarily set to true, set to false if at least one job is not done

        for (int j = 0; j < max; j++) {
            table = outputGridTopComponent.getTabTable(j);
            model = (DefaultTableModel) table.getModel();
            try {
                for (row = 0; row < model.getRowCount(); row++) {
                    //if((Integer)jTable1.getValueAt(row, 0) > 1) continue;      // This should allow us to skip to next directory so we avoid redundant checks.

                    String rec = (String) table.getValueAt(row, getCol(table, "Receptor"));
                    String dir = (String) table.getValueAt(row, getCol(table, "Output Directory"));
                    String lig = (String) table.getValueAt(row, getCol(table, "Ligand"));

                    // This line only IF NOT running obconformer, or else false positive could occur while obconformer is running.
                    //if(files[i].equalsIgnoreCase((String)jTable1.getValueAt(row, 1)+".pdb"))
                    // This line only IF running obconformer, or there will never be Orig_ file.
                    File done = new File(dir + File.separator + "Orig_" + (String) table.getValueAt(row, getCol(table, "Ligand")) + ".pdb");
                    if (rec.length() > 0) {
                        if (lig.endsWith(".pdb")) {
                            lig = lig.substring(lig.lastIndexOf("/"), lig.indexOf(".pdb"));
                        }
                        done = new File(dir + File.separator + lig + "_Reference");
                    }

                    if (done.exists()) {
                        table.setValueAt("Done", row, getCol(table, "Status"));
                        if (((String) table.getValueAt(row, getCol(table, "Secondary"))).length() > 0) {
                            messageWindowTopComponent.appendText("Starting Secondary Ligand Job\n");
                            jobNum = (Integer) table.getValueAt(row, getCol(table, "Job #"));
                            doSecondaryJob(jobNum);
                        }
                    }
                    else //done does not exist
                        allJobsDone = false;
                }


            } catch (java.lang.ArrayIndexOutOfBoundsException e) {
                messageWindowTopComponent.appendText("INVALID ROW SELECTED FOR CHECKING STATUS row [" + row + "]\n");
            }
        }
        
        if(allJobsDone) {
            System.out.println("All jobs are done");
        }
    }//GEN-LAST:event_checkStatusButtonActionPerformed

    private void newTabChBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newTabChBoxActionPerformed
        tabFlag = newTabChBox.isSelected();
    }//GEN-LAST:event_newTabChBoxActionPerformed

    private void ligModCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ligModCheckBoxActionPerformed
        if (ligModCheckBox.isSelected()) {
            ligFromModeller = true;
        } else {
            ligFromModeller = false;
        }

    }//GEN-LAST:event_ligModCheckBoxActionPerformed

    private void recModCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_recModCheckBoxActionPerformed
        if (recModCheckBox.isSelected()) {
            recFromModeller = true;
        } else {
            recFromModeller = false;
        }
    }//GEN-LAST:event_recModCheckBoxActionPerformed

    private void vinaCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_vinaCheckBoxActionPerformed
        if (vinaCheckBox.isSelected()) {
            useVina = true;
            messageWindowTopComponent.appendText(":::::::::WARNING:::::::::\n"
                    + "AutoDock Vina has been selected to be "
                    + "used instead of AutoDock. AutoDock Vina "
                    + "demands a large number of resources per job, "
                    + "make sure to specify in the swarm options "
                    + "that nodes with enough memory (at least 4GB for "
                    + "each job per node) are selected to be used.\n"
                    + "::::::::::::::::::::::::::::::::::\n");
        } else {
            useVina = false;
        }

    }//GEN-LAST:event_vinaCheckBoxActionPerformed

    private void swmJobNumKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_swmJobNumKeyReleased
        swmCmdOpts.setText("swarm -f swarmCmds.txt -n " + swmJobNum.getText() + " -l walltime=128:00:00");
    }//GEN-LAST:event_swmJobNumKeyReleased

    //tlong TODO uncomment later
    private void MutationsCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MutationsCheckBoxActionPerformed
        if(MutationsCheckBox.isSelected()){
            if(ligandField.getText().trim().equals("") || receptorField.getText().trim().equals("") || boxCoordField.getText().trim().equals("")){
                messageWindowTopComponent.appendText("You must first specify a ligand, a receptor, and box coordinates in the appropriate fields above.\n");
                MutationsCheckBox.setSelected(false);
            }else{
                ArrayList<String> seqList = mutantScreeningWizardAction.getFullSequence(ligandField.getText().trim());
                if(seqList.isEmpty()){  //couldn't parse the data file
                    messageWindowTopComponent.appendText("Unable to determine the amino acid sequence from the ligand's pdb file.\n" +
                                                         "Please make sure that it contains the mandatory SEQRES lines and try again.\n");
                    MutationsCheckBox.setSelected(false);
                }else{
                    mutationScreening = true;
                    mutantScreeningWizardAction mutant_screen_wizard = new mutantScreeningWizardAction();
                    mutantScreenParameters = mutant_screen_wizard.initialize(seqList);
                    
                    if(mutantScreenParameters  == null){  //cancel button was selected
                        MutationsCheckBox.setSelected(false);
                        mutationScreening = false;
                    }
                }
            }
        }else{
            mutationScreening = false;
        }
    }//GEN-LAST:event_MutationsCheckBoxActionPerformed

    private void swmCmdOptsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_swmCmdOptsActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_swmCmdOptsActionPerformed


    private void pymolActionPerformed(java.awt.event.MouseEvent evt) {
        table = outputGridTopComponent.getSelectedTable();
        model = (DefaultTableModel) table.getModel();
        String file;
        String dir;
        javax.swing.JFileChooser checker;

        try {
            dir = (String) table.getValueAt(table.getSelectedRow(), getCol(table, "Output Directory"));
            checker = new javax.swing.JFileChooser(dir);
            checker.setDialogTitle("Select PDB File to View");
        } catch (java.lang.ArrayIndexOutOfBoundsException e) {
            checker = new javax.swing.JFileChooser();
            checker.setDialogTitle("Select PDB File to View");
        }

        try {

            int retval = checker.showOpenDialog(openerTopComponent.this);
            if (retval == checker.APPROVE_OPTION) {
                file = checker.getSelectedFile().getPath();
                Process k = Runtime.getRuntime().exec("pymol " + file);
            }

        } catch (java.io.IOException e) {
            messageWindowTopComponent.appendText(e + "\n");
        }
    }

    private void removeSelectedJobActionPerformed(java.awt.event.MouseEvent evt) {
        table = outputGridTopComponent.getSelectedTable();
        model = (DefaultTableModel) table.getModel();
        int[] rowNums = table.getSelectedRows();
        int rowCount = table.getSelectedRowCount();
        int jobNum;

        if (rowCount == 0) {
            messageWindowTopComponent.appendText("NO ROW SELECTED\n");
            return;
        }
        messageWindowTopComponent.appendText("Selected " + rowCount + " Jobs For Removal\n");
        for (int rowNum = rowCount - 1; rowNum >= 0; rowNum--) {
            jobNum = (Integer) table.getValueAt(rowNums[rowNum], getCol(table, "Job #"));
            messageWindowTopComponent.appendText("Killing Job " + jobNum + "\n");
            ((Job) jobList.get(jobNum)).killJob();
            messageWindowTopComponent.appendText("Removing Job " + jobNum + "\n");
            model.removeRow(rowNums[rowNum]);
        }
    }

    private int getCol(JTable tbl, String column) {
        int i = 0;
        int colCount = tbl.getColumnCount();
        String name = new String("");
        for (i = 0; i < colCount; i++) {
            name = tbl.getColumnName(i);
            if (column.equals(name)) {
                return i;
            }
        }
        return i;
    }

    private void StartSelectedJobActionPerformed(java.awt.event.MouseEvent evt) {
        SwingWorker jobStartWorker = new SwingWorker<String, Void>() {

            @Override
            public String doInBackground() {
                table = outputGridTopComponent.getSelectedTable();
                model = (DefaultTableModel) table.getModel();

                String line = null;
                int[] rowNums = table.getSelectedRows();
                int rowCount = table.getSelectedRowCount();
                int jobNum;
                if (rowCount == 0) {
                    messageWindowTopComponent.appendText("NO ROWS SELECTED\n");
                    return "Done";
                }
                messageWindowTopComponent.appendText("Selected " + rowCount + " Jobs For Starting\n");

                // *** Bulk submit *** //
                String[] jobCmds = new String[rowNums.length];

                for (int i = 0; i < jobCmds.length; i++) {
                    jobNum = (Integer) table.getValueAt(rowNums[i], getCol(table, "Job #"));
                    updateJob(rowNums[i]);
                    jobCmds[i] = ((Job) jobList.get(jobNum)).getCmd();
                }
                
                try{
                    //following does not work because env.PATH is not correct, whereas it is for perl script
//                    if(swmCmdOpts.getText().isEmpty()){  //run locally
//                        for(String cmd : jobCmds){
//                            Process procID = Runtime.getRuntime().exec(cmd, null, outDir);
//                            BufferedReader in = new BufferedReader(new InputStreamReader(procID.getErrorStream()));
//                            while ((line = in.readLine()) != null) {
//                                errorLog += line + "\n";
//                            }
//                            messageWindowTopComponent.messageArea.setText("");
//                            messageWindowTopComponent.appendText(errorLog);
//                        }
//                    }else{
                        String base = outDir.getCanonicalPath();
                        String swarmFile = base + File.separator+"swarmCmds.txt";
                        //run swarm Jobs.
                        BufferedWriter swarmOut = new BufferedWriter(new FileWriter(swarmFile));
                        for (int i = 0; i < rowNums.length; i++) {
                            jobNum = (Integer) table.getValueAt(rowNums[i], getCol(table, "Job #"));
    //                        updateJob(rowNums[i]);
    //                        swarmOut.write(((Job) jobList.get(jobNum)).getCmd() + "\n");
                            swarmOut.write(jobCmds[i] + "\n");
                            // Either use the Job class to make commands, or use this one.
                            //swarmOut.write(getCmd(jobNum)+"\n");
                            if (table.getValueAt(rowNums[i], getCol(table, "Status")).equals("Started")) {
                                ((Job) jobList.get(jobNum)).killJob();
                                messageWindowTopComponent.appendText("Restarting Job " + jobNum + "\n");
                            } else {
                                messageWindowTopComponent.appendText("  Starting Job " + jobNum + "\n");
                                table.setValueAt("Started", rowNums[i], getCol(table, "Status"));
                            }
                        }
                        swarmOut.close();
                       
                        Process procID = Runtime.getRuntime().exec(swmCmdOpts.getText(), null, outDir);
                        BufferedReader in = new BufferedReader(new InputStreamReader(procID.getErrorStream()));
                        while ((line = in.readLine()) != null) {
                            errorLog += line + "\n";
                        }
                        messageWindowTopComponent.messageArea.setText("");
                        messageWindowTopComponent.appendText(errorLog);
//                    }
                
                } catch (IOException e) {
                    errorLog = e + "";
                    messageWindowTopComponent.appendText(errorLog);
                    System.out.println(e);
                }
                
                return "Done";
            }
        };

        jobStartWorker.execute();
    }

    private void avgActionPerformed(java.awt.event.MouseEvent evt) {
        Process proc;
        table = outputGridTopComponent.getSelectedTable();
        int row = table.rowAtPoint(evt.getPoint());
        String out = (String) table.getValueAt(row, getCol(table, "Output Directory"));
        outDirField.setText(out);

        if (resChkGpf.length() < 1) {
            messageWindowTopComponent.appendText("No GPF Supplied... Can't check results.\n");
            return;
        }
        String box = resChkGpf;
        String odir = outDirField.getText().trim();

        String cmd = openerTopComponent.class.getResource("openerTopComponent.class").getPath();
        cmd = cmd.substring(cmd.indexOf(":") + 1, cmd.indexOf("modules/"));
        cmd += "lib/scripts/resultCheck.pl";
        // Make sure resultCheck.pl is executable, since Netbeans
        //  changes permissions when creating distribution... neat.
        File tmpfile = new File(cmd);
        tmpfile.setExecutable(true);

        String dir = getDirChoose(lastOutDir, "Select Directory to Analyze");
        if (odir.length() < 1) {
            odir = dir;
        }
        if (dir != null) {
            cmd += " -d " + dir + " -b " + box + " -o " + odir;
            messageWindowTopComponent.appendText("Res Check CMD [" + cmd + "]\n");
            messageWindowTopComponent.appendText("Results written to [" + odir + "/CheckResultsLog_*" + "]\n");
            try {

                proc = Runtime.getRuntime().exec(cmd, null);
            } catch (java.io.IOException e) {
                System.out.println("Caught eX " + e);
            }
        }
    }

    /*
     * adjusts job numbers to reflect any subdirectories that may already exist
     * in the output folder.
     */
    private void alignJobNums() {
        String fContents[] = outDir.list();
        int subNum = 0;
        int tmpNum;

        java.util.Arrays.sort(fContents);

        for (String x : fContents) {
            if (x.contains("dock_")) {
                tmpNum = Integer.parseInt(x.substring(x.indexOf("_") + 1));
                if (tmpNum > subNum) {
                    subNum = tmpNum;
                }
            }
        }

        //if(subNum > 0)  ++subNum;
        currJobNumber = subNum + 1;
    }

    private String getCmd(int row) {
        String seq, tmplt, lig, odir, rec, bc, appd, cyc;

        String cmd = getDockomaticScriptPath();
        // Make sure dockOmatic.pl is executable, since Netbeans
        //  changes permissions when creating distribution... neat.
        File tmpfile = new File(cmd);
        tmpfile.setExecutable(true);

        lig = (String) table.getValueAt(row, getCol(table, "Ligand"));
        odir = (String) table.getValueAt(row, getCol(table, "Output Directory"));
        rec = (String) table.getValueAt(row, getCol(table, "Receptor"));
        bc = (String) table.getValueAt(row, getCol(table, "Box Coordinate"));
        seq = (String) table.getValueAt(row, getCol(table, "Sequence"));
        tmplt = (String) table.getValueAt(row, getCol(table, "Template"));
        cyc = (String) table.getValueAt(row, getCol(table, "AutoDock Cycles"));
        appd = (String) table.getValueAt(row, getCol(table, "Secondary"));


        if (useVina) {
            cmd += " -v ";
        }
        if (seq.length() > 0) {
            cmd += " -m " + seq;
        }
        if (tmplt.length() > 0) {
            cmd += " -t " + tmplt;
        }

        if (lig.length() > 0) {
            cmd += " -p " + lig;
        }
        if (odir.length() > 0) {
            cmd += " -o " + odir;
        }
        if (rec.length() > 0) {
            cmd += " -r " + rec;
        }
        if (bc.length() > 0) {
            cmd += " -b " + bc;
        }
        if (appd.length() > 0) {
            cmd += " -a " + appd;
        }
        if (cyc.length() > 0) {
            cmd += " -g " + cyc;
        }

        return cmd;

    }
    
    private String getDockomaticScriptPath() {
        String classPath = openerTopComponent.class.getResource("openerTopComponent.class").getPath();
        int start = classPath.indexOf(":") + 1;  //ignore file: start
        int end = classPath.indexOf("modules" + File.separator);
        String script_path = classPath.substring(start,end);        
        script_path += "lib" + File.separator + "dockOmatic.pl";

        return script_path;
    }


    /*
     * Walks through arrays of ligands, box Coordinate files, and secondary
     * ligands to creates jobs for all combinations of each.
     */
    private void makeJobs() throws IOException {
        if (totalJobs < 1) {
            outputGridTopComponent.outGridTPane.removeTabAt(0);
            model = (DefaultTableModel) outputGridTopComponent.newTabb();
        } else if (tabFlag) {
            model = (DefaultTableModel) outputGridTopComponent.newTabb();
        } else {
            model = (DefaultTableModel) outputGridTopComponent.getSelectedTab();
        }

        //createTmpFiles();
        int count = readTmpFiles();
        mkSubdirs(count);
        String base = "";

        try {
            base = outDir.getCanonicalPath();//outDirField.getText().trim();
        } catch (java.io.IOException e) {
            System.out.println(e);
            System.exit(0);
        }

        if (base.length() > 0) {
            base += File.separator;
        }

        if (recList.size() != boxList.size()) {
            throw new IOException();
        }

        for (int l = 0; l < ligList.size(); l++) {
            for (int r = 0; r < recList.size(); r++) {
                // for (int b = 0; b < boxList.size(); b++) {
                for (int a = 0; a < appList.size(); a++) {
                    newJob(ligList.get(l), recList.get(r), boxList.get(r), base, appList.get(a),
                            false, false, "", "", swmJobNum.getText(), dockCycles.getText());
                }
                // }
            }
        }

        ligList.clear();
        recList.clear();
        boxList.clear();
        appList.clear();

        //redisplay();
        // start timer to check all job status.
        startJobTimer();
    }

    /*
     * Create subdirectories under main output directory. Each of these
     * subdirectories represents a job.
     */
    private void mkSubdirs(int total) {
        File subDir;
        String subDirName;
        String base = "";
        try {
            base = outDir.getCanonicalPath();
        } catch (java.io.IOException e) {
        }

        if (base.length() > 0) {
            base += File.separator;
        }

        for (int i = currJobNumber; i < total + currJobNumber; i++) {
            subDirName = base + "dock_" + String.format("%0"+PADDING+"d",i);
            subDir = new File(subDirName);
            subDir.mkdir();
        }
    }

    /*
     * If using a list, read in data from the list file. If not using a list,
     * get the info from the text box in the GUI.
     */
    private int readTmpFiles() {
        BufferedReader in;
        String line;
        int ligCount = 0;
        int recCount = 0;
        int boxCount = 0;
        int appCount = 0;

        try {
            if (ligLstBool) {
                ligFile = new File(ligandField.getText().trim());
                in = new BufferedReader(new FileReader(ligFile));
                line = in.readLine();
                while (line != null) {
                    ligList.add(line.trim());
                    line = in.readLine();
                    ligCount++;
                }
                in.close();
            }else if(mutationScreening){ //tlong
                ligList = generateMutantLibrary(ligandField.getText().trim());
                ligCount = ligList.size();
            }else {
                ligList.add(ligandField.getText().trim());
                ligCount++;
            }

            if (recListBool) {
                recFile = new File(receptorField.getText().trim());
                in = new BufferedReader(new FileReader(recFile));
                line = in.readLine();
                while (line != null) {
                    recList.add(line.trim());
                    line = in.readLine();
                    recCount++;
                }
                in.close();
            } else {
                recList.add(receptorField.getText().trim());
                recCount++;
            }

            if (boxListBool) {
                boxFile = new File(boxCoordField.getText().trim());
                in = new BufferedReader(new FileReader(boxFile));
                line = in.readLine();
                while (line != null) {
                    boxList.add(line.trim());
                    line = in.readLine();
                    boxCount++;
                }
                in.close();
            } else {
                boxList.add(boxCoordField.getText().trim());
                boxCount++;
            }

            if (appListBool) {
                appFile = new File(appendField.getText().trim());
                in = new BufferedReader(new FileReader(appFile));
                line = in.readLine();
                while (line != null) {
                    appList.add(line.trim());
                    line = in.readLine();
                    appCount++;
                }
                in.close();
            } else {
                appList.add(appendField.getText().trim());
                appCount++;
            }

        } catch (java.io.IOException e) {
            ++exceptionNum;
            messageWindowTopComponent.appendText(e + " " + exceptionNum + "\n");
        }

        //removeTmpFiles();
        if (recList.size() == boxList.size()) {
            return (ligCount * recCount * appCount);
        } else {
            return (ligCount * recCount * boxCount * appCount);
        }


    }

    // Timer to check the status of each job.
    private void startJobTimer() {
        int delay = 10000;  // 10 seconds
        java.awt.event.ActionListener jobChecker = new java.awt.event.ActionListener() {

            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkStatusButtonActionPerformed(evt);
            }
        };
        jobTimer = new Timer(delay, jobChecker);
        jobTimer.start();
    }

    // Updates jobs in job vector to match any changes that may have taken place
    // in the jobs listed in the GUI.
    private void updateJob(int row) {
        table = outputGridTopComponent.getSelectedTable();

        int job = (Integer) table.getValueAt(row, getCol(table, "Job #"));

        Job tmp = (Job) jobList.get(job);
        tmp.update((String) table.getValueAt(row, getCol(table, "Ligand")),
                (String) table.getValueAt(row, getCol(table, "Output Directory")),
                (String) table.getValueAt(row, getCol(table, "Receptor")),
                (String) table.getValueAt(row, getCol(table, "Box Coordinate")),
                true,
                (String) table.getValueAt(row, getCol(table, "Sequence")),
                (String) table.getValueAt(row, getCol(table, "Template")),
                (String) table.getValueAt(row, getCol(table, "AutoDock Cycles")));

    }

    // Create new job from supplied arguments.
    private void newJob(String lig, String rec, String box, String dir, String app,
            Boolean secondary, Boolean swarm, String seq, String tmplt, String nodeJobs, String cycles) {
        dir = dir + "dock_" + String.format("%0"+PADDING+"d", currJobNumber);

        messageWindowTopComponent.appendText("Creating New Job [" + currJobNumber + "]\n");

        if (secondary) {
            //jobList.add(new Job(currJobNumber, lig, rec, box, dir, true, app, seq, tmplt, cycles, useVina));
            jobList.put(currJobNumber, new Job(currJobNumber, lig, rec, box, dir, true, app, seq, tmplt, cycles, useVina));
            model.addRow(new Object[]{currJobNumber, lig, dir, rec, box, "", "Not Started", seq, tmplt, cycles});
        } else {
            //jobList.add(new Job(currJobNumber, lig, rec, box, dir, true, "", seq, tmplt, cycles, useVina));
            jobList.put(currJobNumber, new Job(currJobNumber, lig, rec, box, dir, true, "", seq, tmplt, cycles, useVina));
            model.addRow(new Object[]{currJobNumber, lig, dir, rec, box, app, "Not Started", seq, tmplt, cycles});
        }

        boxCoordField.setText("");
        receptorField.setText("");
        ligandField.setText("");
        outDirField.setText("");
        appendField.setText("");
        ++currJobNumber;
        ++totalJobs;
    }

    // Removes all jobs from the gui screen and the vector that holds all job objects.
    private void removeAllJobs() {
        table = outputGridTopComponent.getSelectedTable();
        model = (DefaultTableModel) table.getModel();
        //killAllJobs();
        messageWindowTopComponent.appendText("Removing All Jobs from tab\n");
        int jobNum;
        int numRows = model.getRowCount();
        for (int i = numRows - 1; i >= 0; i--) {
            jobNum = (Integer) table.getValueAt(i, getCol(table, "Job #"));
            ((Job) jobList.get(jobNum)).killJob();
            model.removeRow(i);
        }
        //jobTimer.stop();
        //currJobNumber = 0;
        //totalJobs = 0;

    }

    // Creates and starts the AutoDock job for the secondary ligand.
    private void doSecondaryJob(int row) {
        String lig = (String) table.getValueAt(row, getCol(table, "Secondary"));
        String rec = (String) table.getValueAt(row, getCol(table, "Receptor"));
        String box = (String) table.getValueAt(row, getCol(table, "Box Coordinate"));
        String dir = (String) table.getValueAt(row, getCol(table, "Output Directory"));
        String numJobs = (String) table.getValueAt(row, getCol(table, "Jobs per Node"));
        String cycles = (String) table.getValueAt(row, getCol(table, "AutoDock Cycles"));
        String oldLig = ((String) table.getValueAt(row, getCol(table, "Ligand"))).toUpperCase();
        Boolean swarm = false;
        //if((Boolean)table.getValueAt(row, getCol("Use Swarm"))){ swarm = true; }
        swarm = true;
        String app;
        String base = "";

        outDir = new File(dir.trim());

        try {
            base = outDir.getCanonicalPath();
        } catch (java.io.IOException e) {
        }

        if (base.length() > 0) {
            base += File.separator;
        }
        app = base + oldLig + "_rank_1.pdb";

        alignJobNums();
        mkSubdirs(1);
        //newJob(lig, rec, box, base+"dock_"+Integer.toString(currJobNumber), app, true, swarm, "", "");
        newJob(lig, rec, box, base, app, true, swarm, "", "", numJobs, cycles);
        ((Job) jobList.get(jobList.size() - 1)).runJob(false);
        table.setValueAt("Started", model.getRowCount() - 1, getCol(table, "Status"));

    }

    // Creates a String holding names of all .pdb files within a given
    // directory.  The String is used as input to the pymol command.
    private String getPDBNames(File dir) {
        String names = "";
        String tmp;
        File[] flist = dir.listFiles();

        for (File file : flist) {
            tmp = file.toString();
            if (tmp.contains(".pdb")) {
                names += tmp + " ";
            }
        }

        return names;
    }
    
    //tlong
    public ArrayList<String> generateMutantLibrary(String ligPath) {
        ArrayList<String> list = new ArrayList<String>();
        recurse(0, ligPath, list, mutantScreenParameters.getSubstitution_sites(), mutantScreenParameters.getOrigSiteAcids(), mutantScreenParameters.getConstraint_set());
        return list;
    }

    //recursive method to generate all possible mutations given fixed sites and pools
    private void recurse(int index, String runTotal, ArrayList<String> list,int[] sub_sites, String origSiteAcids, String[] constraint_set) {
        if (index == sub_sites.length){ //end of the line, add it to the list
            list.add(runTotal);
        } else {
            for (int num = 0; num < constraint_set[index].length(); num++){ //for each acid in the set
                if (constraint_set[index].charAt(num) == origSiteAcids.charAt(index)){ //no mutation at this spot, continue on
                    recurse(index + 1, runTotal, list,sub_sites,origSiteAcids,constraint_set);
                } else {
                    recurse(index + 1, runTotal + ":" + origSiteAcids.charAt(index) + sub_sites[index] + constraint_set[index].charAt(num), list,sub_sites,origSiteAcids,constraint_set);
                }
            }
        }
    }
    
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton LigandButton;
    private javax.swing.JCheckBox MutationsCheckBox;
    private static javax.swing.JCheckBox appCheckBox;
    protected static javax.swing.JButton appendButton;
    private static javax.swing.JTextField appendField;
    private javax.swing.JButton boxCoordButton;
    private javax.swing.JCheckBox boxCoordCheckBox;
    private javax.swing.JTextField boxCoordField;
    private javax.swing.JTextField dockCycles;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel10;
    private javax.swing.JPanel jPanel8;
    private javax.swing.JPanel jPanel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JSeparator jSeparator4;
    private javax.swing.JSeparator jSeparator5;
    private javax.swing.JSeparator jSeparator6;
    private javax.swing.JCheckBox ligModCheckBox;
    private javax.swing.JCheckBox ligandCheckBox;
    private javax.swing.JTextField ligandField;
    private javax.swing.JButton newJobButton;
    private javax.swing.JCheckBox newTabChBox;
    private javax.swing.JButton outDirButton;
    private javax.swing.JTextField outDirField;
    private javax.swing.JCheckBox recModCheckBox;
    private javax.swing.JButton receptorButton;
    private javax.swing.JCheckBox receptorCheckBox;
    private javax.swing.JTextField receptorField;
    private javax.swing.JTextField swmCmdOpts;
    private javax.swing.JTextField swmJobNum;
    private javax.swing.JCheckBox vinaCheckBox;
    // End of variables declaration//GEN-END:variables

    /**
     * Gets default instance. Do not use directly: reserved for *.settings files
     * only, i.e. deserialization routines; otherwise you could get a
     * non-deserialized instance. To obtain the singleton instance, use {@link #findInstance}.
     */
    public static synchronized openerTopComponent getDefault() {
        if (instance == null) {
            instance = new openerTopComponent();
        }
        return instance;
    }

    /**
     * Obtain the openerTopComponent instance. Never call {@link #getDefault}
     * directly!
     */
    public static synchronized openerTopComponent findInstance() {
        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);
        if (win == null) {
            Logger.getLogger(openerTopComponent.class.getName()).warning(
                    "Cannot find " + PREFERRED_ID + " component. It will not be located properly in the window system.");
            return getDefault();
        }
        if (win instanceof openerTopComponent) {
            return (openerTopComponent) win;
        }
        Logger.getLogger(openerTopComponent.class.getName()).warning(
                "There seem to be multiple components with the '" + PREFERRED_ID
                + "' ID. That is a potential source of errors and unexpected behavior.");
        return getDefault();
    }

    @Override
    public int getPersistenceType() {
        return TopComponent.PERSISTENCE_ALWAYS;
    }

    @Override
    public void componentOpened() {
        // TODO add custom code on component opening
    }

    @Override
    public void componentClosed() {
        // TODO add custom code on component closing
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
    }

    Object readProperties(java.util.Properties p) {
        if (instance == null) {
            instance = this;
        }
        instance.readPropertiesImpl(p);
        return instance;
    }

    private void readPropertiesImpl(java.util.Properties p) {
        String version = p.getProperty("version");
    }

    @Override
    protected String preferredID() {
        return PREFERRED_ID;
    }
}